# -*- coding: utf-8 -*-
"""Healthify Capstone Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DyK5Dd3vH-faEjXe--RxquRZ2i05TtrZ
"""

import math
import numpy as np
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from tensorflow.keras.layers import DenseFeatures
from tensorflow.feature_column import categorical_column_with_hash_bucket, numeric_column, embedding_column

from google.colab import drive
drive.mount('/content/drive')

data = pd.read_excel('/content/drive/MyDrive/DataSet Makanan Indo Bersih.xls')
data2 = data



data.head()

data.tail()

data.info()

data.shape

data.isna().sum()

data.info()



features = data.drop(columns = ['No.','Kode', 'Nama Bahan Makanan', 'Energi(Kal)'])

features

targets = data.drop(columns= ['No.','Kode', 'Nama Bahan Makanan', 'Protein(g)', 'Lemak(g)', 'Karbohidrat(g)'])

targets

np.unique(targets)

len(np.unique(targets))

model = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation = 'relu', input_shape=(3,)),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(64, activation = 'relu'),
    tf.keras.layers.Dense(32, activation = 'relu'),
    tf.keras.layers.Dense(1, activation = 'linear')
])

model.compile(optimizer=tf.keras.optimizers.Adam(0.0001),
              loss='mse')

model.fit(features, targets, epochs = 50, validation_split = 0.2, verbose = 2)

model.predict(features.head(2))

protein_features = data.drop(columns = ['No.','Kode', 'Nama Bahan Makanan', 'Protein(g)'])

protein_targets = data.drop(columns = ['No.','Kode', 'Nama Bahan Makanan', 'Energi(Kal)', 'Lemak(g)', 'Karbohidrat(g)'])

model_protein = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation = 'relu', input_shape=(3,)),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(64, activation = 'relu'),
    tf.keras.layers.Dense(32, activation = 'relu'),
    tf.keras.layers.Dense(1, activation = 'linear')
])

model_protein.compile(optimizer=tf.keras.optimizers.Adam(0.0001),
              loss='mse')

model_protein.fit(protein_features, protein_targets, epochs = 50, validation_split = 0.2, verbose = 2)

model_protein.predict(protein_features.head(1))

lemak_features = data.drop(columns = ['No.','Kode', 'Nama Bahan Makanan', 'Lemak(g)'])

lemak_targets = data.drop(columns = ['No.','Kode', 'Nama Bahan Makanan', 'Energi(Kal)', 'Protein(g)', 'Karbohidrat(g)'])

model_lemak = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation = 'relu', input_shape=(3,)),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(64, activation = 'relu'),
    tf.keras.layers.Dense(32, activation = 'relu'),
    tf.keras.layers.Dense(1, activation = 'linear')
])

model_lemak.compile(optimizer=tf.keras.optimizers.Adam(0.0001),
              loss='mse')

model_lemak.fit(lemak_features, lemak_targets, epochs = 50, validation_split = 0.2, verbose = 2)

model_lemak.predict(lemak_features.head(1))

karbohidrat_features = data.drop(columns = ['No.','Kode', 'Nama Bahan Makanan', 'Karbohidrat(g)'])

karbohidrat_targets = data.drop(columns = ['No.','Kode', 'Nama Bahan Makanan', 'Energi(Kal)', 'Protein(g)', 'Lemak(g)'])

model_karbohidrat = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation = 'relu', input_shape=(3,)),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(64, activation = 'relu'),
    tf.keras.layers.Dense(32, activation = 'relu'),
    tf.keras.layers.Dense(1, activation = 'linear')
])

model_karbohidrat.compile(optimizer=tf.keras.optimizers.Adam(0.0001), loss='mse')

model_karbohidrat.fit(karbohidrat_features, karbohidrat_targets, epochs = 50, validation_split = 0.2, verbose = 2)

model_karbohidrat.predict(karbohidrat_features.head(1))

"""**Recommender**"""

import random

def recommend_foods(data, calorie_limit, tolerance=50):
    # Shuffle the dataframe
    data = data.sample(frac=1, random_state=random.randint(0, 1000))

    # Initialize an empty list to hold the recommended foods
    recommended_foods = []

    # Initialize a variable to hold the total calories of the recommended foods
    total_calories = 0

    # Iterate over the rows of the shuffled dataframe
    for index, row in data.iterrows():
        # If adding the current food does not exceed the calorie limit
        if total_calories + row['Energi(Kal)'] <= calorie_limit + tolerance:
            # Add the food and its calorie content to the list of recommended foods
            recommended_foods.append((row['Nama Bahan Makanan'], row['Energi(Kal)']))
            # Add the calories of the current food to the total calories
            total_calories += row['Energi(Kal)']
        # If the total calories is close to the calorie limit, stop adding foods
        if total_calories >= calorie_limit:
            break

    return recommended_foods, total_calories

# Call the function
foods, total_calories = recommend_foods(data, 2000)
for food, calories in foods:
    print(f"Food: {food}, Calories: {np.round(calories, 1)}")
print(f"Total Calories: {np.round(total_calories, 1)}")

import numpy as np
import tensorflow as tf
import random

# Number of items
num_items = len(data)

# Weights and values
weights = data['Lemak(g)'].values  # We use fat as the weight
values = data['Energi(Kal)'].values  # We use calories as the value

# Knapsack capacity
capacity = 30  # This is the total amount of fat we want to minimize

# State: (current weight, item, total value)
state = tf.keras.Input(shape=(3,))

# Q-values: (do nothing, pick item)
q_values = tf.keras.layers.Dense(2)(state)

# Model
model3 = tf.keras.Model(inputs=state, outputs=q_values)

# Loss and optimizer
loss_fn = tf.keras.losses.MeanSquaredError()
optimizer = tf.keras.optimizers.Adam()

# Discount factor
gamma = 0.95

# Epsilon for epsilon-greedy strategy
epsilon = 1.0
epsilon_decay = 0.995

# Training loop
stop_training = False
selected_foods = []  # Initialize an empty list to store selected foods

for episode in range(1000):  # Increase the number of episodes
    # Initial state
    current_weight = 0
    total_value = 0

    for item in range(num_items):
        # Current state
        current_state = np.array([[current_weight, item, total_value]])

        # Compute Q-values
        current_q_values = model3.predict(current_state)

        # Choose action
        if np.random.rand() < epsilon:
            action = np.random.randint(2)
        else:
            action = np.argmax(current_q_values)

        # Update current weight and total value
        if action == 1 and current_weight + weights[item] <= capacity:
            current_weight += weights[item]
            total_value += values[item]

            # Save the selected item if the weight and value constraints are met
            selected_foods.append((data['Nama Bahan Makanan'][item], values[item]))

        # Print the weights and total value per loop
        print(f"Current weight: {current_weight}, Total value: {total_value}")

        # Compute reward
        reward = total_value - current_weight  # Adjust the reward function

        # Next state
        next_state = np.array([[current_weight, item + 1, total_value]])

        # Compute next Q-values
        next_q_values = model3.predict(next_state)

        # Compute target Q-values
        target_q_values = current_q_values
        target_q_values[0, action] = reward + gamma * np.max(next_q_values)

        # Update model
        with tf.GradientTape() as tape:
            q_values = model3(current_state)
            loss = loss_fn(target_q_values, q_values)
        grads = tape.gradient(loss, model3.trainable_weights)
        optimizer.apply_gradients(zip(grads, model3.trainable_weights))

        # Check if the total value exceeds 2000 and break both loops
        if total_value >= 2000:
            print("Total value exceeds 2000. Stopping training.")
            stop_training = True
            break

    # Decrease epsilon
    epsilon *= epsilon_decay

    if stop_training:
        break

# Print the recommended foods
print("Recommended Foods:")
for food, calories in selected_foods:
    print(f"Food: {food}, Calories: {calories}")

print(f"Total Calories: {sum(calories for _, calories in selected_foods)}")